/* Auto-generated by genmsg_cpp for file /home/karthikl/ResearchCode/groovy_workspace/sandbox/mas_exploration/environments/mas_egraphs/srv/GetXYThetaPlan.srv */
#ifndef MAS_EGRAPHS_SERVICE_GETXYTHETAPLAN_H
#define MAS_EGRAPHS_SERVICE_GETXYTHETAPLAN_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"

#include "ros/service_traits.h"




namespace mas_egraphs
{
template <class ContainerAllocator>
struct GetXYThetaPlanRequest_ {
  typedef GetXYThetaPlanRequest_<ContainerAllocator> Type;

  GetXYThetaPlanRequest_()
  : num_agents(0)
  , num_goals(0)
  , start_x()
  , start_y()
  , start_z()
  , start_theta()
  , goal_x()
  , goal_y()
  , goal_z()
  , goal_theta()
  , egraph_eps(0.0)
  , final_egraph_eps(0.0)
  , dec_egraph_eps(0.0)
  , initial_eps(0.0)
  , final_eps(0.0)
  , dec_eps(0.0)
  , feedback_path(false)
  , save_egraph(false)
  , use_egraph(false)
  {
  }

  GetXYThetaPlanRequest_(const ContainerAllocator& _alloc)
  : num_agents(0)
  , num_goals(0)
  , start_x(_alloc)
  , start_y(_alloc)
  , start_z(_alloc)
  , start_theta(_alloc)
  , goal_x(_alloc)
  , goal_y(_alloc)
  , goal_z(_alloc)
  , goal_theta(_alloc)
  , egraph_eps(0.0)
  , final_egraph_eps(0.0)
  , dec_egraph_eps(0.0)
  , initial_eps(0.0)
  , final_eps(0.0)
  , dec_eps(0.0)
  , feedback_path(false)
  , save_egraph(false)
  , use_egraph(false)
  {
  }

  typedef int32_t _num_agents_type;
  int32_t num_agents;

  typedef int32_t _num_goals_type;
  int32_t num_goals;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _start_x_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  start_x;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _start_y_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  start_y;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _start_z_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  start_z;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _start_theta_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  start_theta;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _goal_x_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  goal_x;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _goal_y_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  goal_y;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _goal_z_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  goal_z;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _goal_theta_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  goal_theta;

  typedef double _egraph_eps_type;
  double egraph_eps;

  typedef double _final_egraph_eps_type;
  double final_egraph_eps;

  typedef double _dec_egraph_eps_type;
  double dec_egraph_eps;

  typedef double _initial_eps_type;
  double initial_eps;

  typedef double _final_eps_type;
  double final_eps;

  typedef double _dec_eps_type;
  double dec_eps;

  typedef uint8_t _feedback_path_type;
  uint8_t feedback_path;

  typedef uint8_t _save_egraph_type;
  uint8_t save_egraph;

  typedef uint8_t _use_egraph_type;
  uint8_t use_egraph;


  typedef boost::shared_ptr< ::mas_egraphs::GetXYThetaPlanRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::mas_egraphs::GetXYThetaPlanRequest_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct GetXYThetaPlanRequest
typedef  ::mas_egraphs::GetXYThetaPlanRequest_<std::allocator<void> > GetXYThetaPlanRequest;

typedef boost::shared_ptr< ::mas_egraphs::GetXYThetaPlanRequest> GetXYThetaPlanRequestPtr;
typedef boost::shared_ptr< ::mas_egraphs::GetXYThetaPlanRequest const> GetXYThetaPlanRequestConstPtr;



template <class ContainerAllocator>
struct GetXYThetaPlanResponse_ {
  typedef GetXYThetaPlanResponse_<ContainerAllocator> Type;

  GetXYThetaPlanResponse_()
  : stat_names()
  , stat_values()
  {
  }

  GetXYThetaPlanResponse_(const ContainerAllocator& _alloc)
  : stat_names(_alloc)
  , stat_values(_alloc)
  {
  }

  typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _stat_names_type;
  std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  stat_names;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _stat_values_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  stat_values;


  typedef boost::shared_ptr< ::mas_egraphs::GetXYThetaPlanResponse_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::mas_egraphs::GetXYThetaPlanResponse_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct GetXYThetaPlanResponse
typedef  ::mas_egraphs::GetXYThetaPlanResponse_<std::allocator<void> > GetXYThetaPlanResponse;

typedef boost::shared_ptr< ::mas_egraphs::GetXYThetaPlanResponse> GetXYThetaPlanResponsePtr;
typedef boost::shared_ptr< ::mas_egraphs::GetXYThetaPlanResponse const> GetXYThetaPlanResponseConstPtr;


struct GetXYThetaPlan
{

typedef GetXYThetaPlanRequest Request;
typedef GetXYThetaPlanResponse Response;
Request request;
Response response;

typedef Request RequestType;
typedef Response ResponseType;
}; // struct GetXYThetaPlan
} // namespace mas_egraphs

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::mas_egraphs::GetXYThetaPlanRequest_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::mas_egraphs::GetXYThetaPlanRequest_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::mas_egraphs::GetXYThetaPlanRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "27aa1da6e9941d3c85e32253d30d7e1c";
  }

  static const char* value(const  ::mas_egraphs::GetXYThetaPlanRequest_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x27aa1da6e9941d3cULL;
  static const uint64_t static_value2 = 0x85e32253d30d7e1cULL;
};

template<class ContainerAllocator>
struct DataType< ::mas_egraphs::GetXYThetaPlanRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "mas_egraphs/GetXYThetaPlanRequest";
  }

  static const char* value(const  ::mas_egraphs::GetXYThetaPlanRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::mas_egraphs::GetXYThetaPlanRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "int32 num_agents\n\
int32 num_goals\n\
\n\
float64[] start_x\n\
float64[] start_y\n\
float64[] start_z\n\
float64[] start_theta\n\
\n\
float64[] goal_x\n\
float64[] goal_y\n\
float64[] goal_z\n\
float64[] goal_theta\n\
\n\
float64 egraph_eps\n\
float64 final_egraph_eps\n\
float64 dec_egraph_eps\n\
\n\
float64 initial_eps\n\
float64 final_eps\n\
float64 dec_eps\n\
\n\
bool feedback_path\n\
bool save_egraph\n\
bool use_egraph\n\
\n\
\n\
";
  }

  static const char* value(const  ::mas_egraphs::GetXYThetaPlanRequest_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros


namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::mas_egraphs::GetXYThetaPlanResponse_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::mas_egraphs::GetXYThetaPlanResponse_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::mas_egraphs::GetXYThetaPlanResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "911eb2a312779ab8da6872ef63023f94";
  }

  static const char* value(const  ::mas_egraphs::GetXYThetaPlanResponse_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x911eb2a312779ab8ULL;
  static const uint64_t static_value2 = 0xda6872ef63023f94ULL;
};

template<class ContainerAllocator>
struct DataType< ::mas_egraphs::GetXYThetaPlanResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "mas_egraphs/GetXYThetaPlanResponse";
  }

  static const char* value(const  ::mas_egraphs::GetXYThetaPlanResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::mas_egraphs::GetXYThetaPlanResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "\n\
string[] stat_names\n\
float64[] stat_values\n\
\n\
\n\
";
  }

  static const char* value(const  ::mas_egraphs::GetXYThetaPlanResponse_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::mas_egraphs::GetXYThetaPlanRequest_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.num_agents);
    stream.next(m.num_goals);
    stream.next(m.start_x);
    stream.next(m.start_y);
    stream.next(m.start_z);
    stream.next(m.start_theta);
    stream.next(m.goal_x);
    stream.next(m.goal_y);
    stream.next(m.goal_z);
    stream.next(m.goal_theta);
    stream.next(m.egraph_eps);
    stream.next(m.final_egraph_eps);
    stream.next(m.dec_egraph_eps);
    stream.next(m.initial_eps);
    stream.next(m.final_eps);
    stream.next(m.dec_eps);
    stream.next(m.feedback_path);
    stream.next(m.save_egraph);
    stream.next(m.use_egraph);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct GetXYThetaPlanRequest_
} // namespace serialization
} // namespace ros


namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::mas_egraphs::GetXYThetaPlanResponse_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.stat_names);
    stream.next(m.stat_values);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct GetXYThetaPlanResponse_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace service_traits
{
template<>
struct MD5Sum<mas_egraphs::GetXYThetaPlan> {
  static const char* value() 
  {
    return "2b24dbb396334e539daff2824444afeb";
  }

  static const char* value(const mas_egraphs::GetXYThetaPlan&) { return value(); } 
};

template<>
struct DataType<mas_egraphs::GetXYThetaPlan> {
  static const char* value() 
  {
    return "mas_egraphs/GetXYThetaPlan";
  }

  static const char* value(const mas_egraphs::GetXYThetaPlan&) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<mas_egraphs::GetXYThetaPlanRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "2b24dbb396334e539daff2824444afeb";
  }

  static const char* value(const mas_egraphs::GetXYThetaPlanRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<mas_egraphs::GetXYThetaPlanRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "mas_egraphs/GetXYThetaPlan";
  }

  static const char* value(const mas_egraphs::GetXYThetaPlanRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<mas_egraphs::GetXYThetaPlanResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "2b24dbb396334e539daff2824444afeb";
  }

  static const char* value(const mas_egraphs::GetXYThetaPlanResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<mas_egraphs::GetXYThetaPlanResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "mas_egraphs/GetXYThetaPlan";
  }

  static const char* value(const mas_egraphs::GetXYThetaPlanResponse_<ContainerAllocator> &) { return value(); } 
};

} // namespace service_traits
} // namespace ros

#endif // MAS_EGRAPHS_SERVICE_GETXYTHETAPLAN_H

